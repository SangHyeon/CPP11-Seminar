#10월 1일 멤 C++11 전파세미나

###복사 생성자
	class A {
    	...pointer...
        char* name;
    };
    
    ~A() { delete[] name;}
    
위 클래스를 동적할당 후 디폴트 소멸자로 소멸되는 경우 메모리 누수가 발생함
또한 위의 소멸자를 사용하여 삭제하는 경우 디폴트 복사 생성자로 생성된 객체의 경우에는 name*의 주소가 복사가 되면서(그냥 = 으로 복사하기때문) 소멸자가 생성될 때 같은 메로리 주소의 메모리를 해제해주기 때문에 오류가 생김

**얕은 복사(Shallow Copy)를 깊은 복사(Deep Copy)로 해주면 해결됨**
복사 생성자를 새로 정의하여 다시 메모리를 할당하여 복사함

####**실무에서는 깊은 복사를 사용하지 않음**
오버헤드가 큼...
####복사 기법
1. Deep Copy
2. Reference Counting
3. 소유권 이전 -> 후에 move로 발전
4. 복사 금지

#####Reference Counting --> shared_ptr
얕은 복사를 사용한다.
메모리를 새로 생성하는게 아니라 참조 횟수를 재면서 사용...(메모리 및 메모리 할당 시간 절약)
만일 공유하는 메모리에 있는 값을 변경하는 경우에는 깊은 복사를 사용하여 메모리를 새로 할당해야한다.(COW : Copy On Write?)

#####소유권 이전 --> unique_ptr
>1. 얕은 복사
>2. 이전 객체의 모든 값을 0으로

C++에서 delete 0; 은 무효처리
auto_ptr은 소유권 이전으로 만들어짐
소유권 이전은 완벽하지가 않음 
- 후에 인수인계 받은 사람이 소유권 이전이 된 객체인지 모르는 경우에 문제가 생김
- C++11에서 완벽해짐...
- 사용자가 예측할 수 없다
	- `a=b` 를 `a=move(b)`로 사용하여 사용자가 예측할 수 있음
- STL Container 사용 불가
	- `v.push_back(move)`로 사용...? move에 대한 동작을 해줌

>C\++98 : 얕은 생성자, 깊은 생성자
>C++11 : 얕은 생성자, 깊은 생성자, 이동 생성자

#####복사 금지
미정의 동작은 원천적으로 봉쇄하자!
복사를 할 상황이 없는 객체를 복사하게 된다면, 컴파일 에러를 발생시켜 복사를 하지 못하도록 함
private에 생성자와 연산자 오러로딩을 선언함
컴파일 에러는 어디서 잘못됬는지 알 수 있지만 런타임 에러는 알 수 없음

싱글턴 패턴을 사용하도록하게 됨

#####auto_ptr을 대체하여 unique_ptr을 사용
RAII 패턴!! : 리소스는 탄생과 동시에 객체가 감싸고 객체는 소멸될때 리소스를 할당 해제함...?